[Документация](https://docs.python.org/3/library/re.html#re-syntax) для регулярных выражений в Python
Регулярки протестить можно [здесь](https://regex101.com/)
любой символ в регулярном выражении соответствует самому себе. Но есть метасимволы:
. ^ $ * + ? { [ ] \ | ( )

[] - используются для определения "класса символов" с которыми ищется совпадение, например перечисление [a, b, c] - любой из этого списка - a, b или c. Можно задавать диапазоны через тире [a-c]. Внутри такого определения класса не работают мета символы. Например выражение [abc$] будет искать a, b, c или $

^ - внутри класса означает "не" - тоесть в \[^5] значит лбой символ не "5" 

\ - экранирование символов

\\d - любая цифра - [0-9]
\\D - любая не цифра [\^0-9]
\\s - пробельные символы [\\t\\n\\r\\f\\v]
\\S - любые не пробельные символы [\^\\t\\n\\r\\f\\v]
\\w - любая буква или цифра [a-zA-Z0-9_]
\\W - [\^a-zA-Z0-9_]

. - соответствует любому символу кроме символа новой строки

\* - указывает количество повторений **ноль** и более раз префиксного символа, например ca\*t - cat, caat, caaat и т.д. 

Пошаговое рассмотрение какого-нибудь примера сделает объяснение более ясным. Давайте рассмотрим выражение `a[bcd]*b`. Оно соответствует букве `'a'`, нулю или более символов из класса `[bcd]`, и наконец, заключительной букве `'b'`. Теперь представим себе сопоставление этого регулярного выражения строке `abcbd`. Вот как происходит сравнение поэтапно:  
  
1. `a` — 'a' соответствует регулярному выражению  
2. `abcbd` — движок сопоставляет `[bcd]*` на как можно большем числе символов, то есть до конца строки (поскольку все символы соответствуют классу в скобках [])  
3. Провал — движок пытается сопоставить последний символ в регулярном выражении — букву `b`, но текущая позиция уже в конце строки, где нет никаких символов, так что он терпит неудачу.  
4. `abcb` — вернулись назад, уменьшили на один символ сопоставление с `[bcd]*`  
5. Провал — пытаемся снова найти `b`, но в конце только `d`  
6. `abc` — снова возвращаемся назад, теперь `[bcd]*` это только bc  
7. `abcb` — снова ищем последний символ регулярного выражения — b. Теперь он действительно находится на нужной позиции и мы добиваемся успеха

\+ - требует по крайней мере хотя бы одно вхождение. ca+t не будет сопоставляться с ct. но зато найдет caaaaat и т.д.

? - сопоставляет повторение ноль или один раз. например `home-?brew` соответствует как `homebrew`, так и `home-brew`

{m, n} - означает не менее m и не более n префиксных значений: `a/{1,3}b` соответствует только `a/b`, `a//b` и `a///b`. По умолчанию m = 0, n = бесконечность.

?= - позитивный просмотр вперед. Логику позитивного просмотра вперед можно описать следующим образом. Регулярное выражение `a(?=b)` находит совпадения таких `a`, за которыми следует `b`, при этом не делая `b` частью сопоставления. 
Кароче ищет такое а, за которым есть b но выдаст в результате он только а

?:[] - обозначает незахватывающую группу. в общем при ?:[abdc] будет искать именно abdc а не любой из этих символов

парсинг данных 
разбиение на подстроки в кавычках и все остальное разбитое по пробелам

r"\\s(?=(?:\[^\"]*\"\[^\"]*\")*\[^\"]*$)"

\\s - обозначет любой пробельный символ
	(?= - ищет все такие пробелы, после которых есть следующее
		(?: - незахватывающая группа. значит что символы сравниваются не "или", а "и"
			\[^\\"]\* - любой символ НЕ кавычки, встречающийся 0 и более раз
			\\" - кавычки
			\[^\"]* - снова НЕ кавычки 0 и более раз
			\" - закрывающие кавычки
		)* - это все может повторяться 0 и более раз - это наша строка в кавычках. Незахватывающая группа закрывается
		\[^\"]* - любое выражение без кавычек 0 и более раз
		$ - окончание строки
	)
